//+------------------------------------------------------------------+
//|                                                      ProjectName |
//|                                      Copyright 2020, CompanyName |
//|                                       http://www.companyname.net |
//+------------------------------------------------------------------+
#include <Trade/Trade.mqh>
CTrade trade;

// ===== USER SETTINGS =====
input double RiskPercent = 2.5;        // For small account (balanced)
input int FastEMA = 50;
input int SlowEMA = 200;
input int RSI_Period = 14;
input int ATR_Period = 14;             
input double ATR_Multiplier = 2.2;
input double TP_Multiplier = 1.4;
input int CooldownSeconds = 30;
input int MagicNumber = 99001;

// Loss Recovery
input double LossLotMultiplier = 0.5;   // Reduce lot after loss

datetime lastTradeTime = 0;
double recoveryFactor = 1.0;

// Indicator handles and values
int fastEMA_handle, slowEMA_handle, rsi_handle, atr_handle;
double fastEMA, slowEMA, rsi, atr;

// ===== AUTO LOT SIZE =====
double AutoLot(double sl_points)
{
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk = balance * (RiskPercent / 100.0) * recoveryFactor;

    double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double lotStep  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    double minLot   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

    double lot = risk / (sl_points * tickValue);
    lot = MathFloor(lot / lotStep) * lotStep;

    if(lot < minLot) lot = minLot;
    if(lot > maxLot) lot = maxLot;

    return lot;
}

// ===== CHECK OPEN TRADE FOR THIS SYMBOL =====
bool HasOpenTrade()
{
    for(int i = 0; i < PositionsTotal(); i++)
    {
        if(PositionSelectByIndex(i))
        {
            string sym = PositionGetString(POSITION_SYMBOL);
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(sym == _Symbol && magic == MagicNumber)
                return true;
        }
    }
    return false;
}

// ===== CHECK LAST TRADE RESULT =====
void UpdateRecovery()
{
    HistorySelect(TimeCurrent()-86400, TimeCurrent());
    int deals = HistoryDealsTotal();
    if(deals == 0)
    {
        recoveryFactor = 1.0;
        return;
    }

    for(int i = deals-1; i >= 0; i--)
    {
        ulong ticket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(ticket, DEAL_SYMBOL) == _Symbol &&
           HistoryDealGetInteger(ticket, DEAL_MAGIC) == MagicNumber)
        {
            double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
            recoveryFactor = (profit < 0) ? LossLotMultiplier : 1.0;
            return;
        }
    }
    recoveryFactor = 1.0;
}

// ===== INITIALIZE INDICATORS =====
void InitializeIndicators()
{
    fastEMA_handle = iMA(_Symbol, PERIOD_CURRENT, FastEMA, 0, MODE_EMA, PRICE_CLOSE);
    slowEMA_handle = iMA(_Symbol, PERIOD_CURRENT, SlowEMA, 0, MODE_EMA, PRICE_CLOSE);
    rsi_handle = iRSI(_Symbol, PERIOD_CURRENT, RSI_Period, PRICE_CLOSE);
    atr_handle = iATR(_Symbol, PERIOD_CURRENT, ATR_Period);
}

// ===== MAIN LOOP =====
void OnTick()
{
    // Initialize indicators once
    static bool initialized = false;
    if(!initialized)
    {
        InitializeIndicators();
        initialized = true;
    }

    UpdateRecovery();

    // Cooldown check
    if(TimeCurrent() - lastTradeTime < CooldownSeconds)
        return;

    // Skip if trade already exists
    if(HasOpenTrade())
        return;

    // Copy indicator buffers
    double fastEMA_buf[1], slowEMA_buf[1], rsi_buf[1], atr_buf[1];
    if(CopyBuffer(fastEMA_handle, 0, 0, 1, fastEMA_buf) != 1 ||
       CopyBuffer(slowEMA_handle, 0, 0, 1, slowEMA_buf) != 1 ||
       CopyBuffer(rsi_handle, 0, 0, 1, rsi_buf) != 1 ||
       CopyBuffer(atr_handle, 0, 0, 1, atr_buf) != 1)
        return;

    fastEMA = fastEMA_buf[0];
    slowEMA = slowEMA_buf[0];
    rsi = rsi_buf[0];
    atr = atr_buf[0];

    if(fastEMA == EMPTY_VALUE || slowEMA == EMPTY_VALUE || rsi == EMPTY_VALUE || atr == EMPTY_VALUE)
        return;

    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double sl_points = atr * ATR_Multiplier / _Point;
    double tp_points = sl_points * TP_Multiplier;
    double lot = AutoLot(sl_points);

    // Avoid tiny invalid lots
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    if(lot < minLot) return;

    bool uptrend = fastEMA > slowEMA;
    bool downtrend = fastEMA < slowEMA;

    trade.SetExpertMagicNumber(MagicNumber);

    // BUY
    if(uptrend && rsi < 30)
    {
        double sl_buy = ask - sl_points * _Point;
        double tp_buy = ask + tp_points * _Point;

        if(trade.Buy(lot, _Symbol, 0, sl_buy, tp_buy) &&
           trade.ResultRetcode() == TRADE_RETCODE_DONE)
        {
            lastTradeTime = TimeCurrent();
            Print("BUY executed: Lot=", lot, " SL=", sl_buy, " TP=", tp_buy);
        }
    }

    // SELL
    if(downtrend && rsi > 70)
    {
        double sl_sell = bid + sl_points * _Point;
        double tp_sell = bid - tp_points * _Point;

        if(trade.Sell(lot, _Symbol, 0, sl_sell, tp_sell) &&
           trade.ResultRetcode() == TRADE_RETCODE_DONE)
        {
            lastTradeTime = TimeCurrent();
            Print("SELL executed: Lot=", lot, " SL=", sl_sell, " TP=", tp_sell);
        }
    }
}
//+------------------------------------------------------------------+
